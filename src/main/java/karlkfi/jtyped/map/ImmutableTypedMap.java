/*******************************************************************************
 * Copyright 2013 Karl Isenberg
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *   http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 ******************************************************************************/
package karlkfi.jtyped.map;

import java.util.Collections;
import java.util.Map;
import java.util.Map.Entry;

import javax.annotation.Nonnull;
import javax.annotation.Nullable;

import karlkfi.jtyped.ImmutableTypedSupplier;
import karlkfi.jtyped.TypedSupplier;

import com.google.common.base.Function;
import com.google.common.collect.Collections2;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Maps;
import com.google.common.reflect.TypeToken;

/**
 * Immutable TypedMap that is backed by an {@link ImmutableMap}.
 * 
 * This implementation hopefully provides all of the friendliness of an ImmutableMap, despite the added complexity of a
 * TypedMap. 
 * 
 * Because values are stored as {@link TypedSupplier}s you can memoize them for cached performance.
 * 
 * Note that while keys are immutable values may not be and thus this map is only shallowly immutable.
 * 
 * @param <ID> the key ID type
 */
public abstract class ImmutableTypedMap<ID> implements TypedMap<ID> {

	/**
	 * Returns the empty typed map.
	 */
	// Casting to any type is safe because the set will never hold any elements.
	@SuppressWarnings("unchecked")
	public static <I> ImmutableTypedMap<I> of() {
		return (ImmutableTypedMap<I>) EmptyImmutableTypedMap.INSTANCE;
	}

	/**
	 * Returns an immutable typed map containing a single entry. This map behaves and performs comparably to
	 * {@link Collections#singletonMap} but will not accept a null key or value. It is preferable mainly for consistency
	 * and maintainability of your code.
	 */
	public static <I> ImmutableTypedMap<I> of(I k1, TypedSupplier<?> v1) {
		return new RegularImmutableTypedMap<I>(ImmutableMap.of(k1, v1));
	}

	/**
	 * Returns an immutable map containing the given entries, in order.
	 * 
	 * @throws IllegalArgumentException if duplicate keys are provided
	 */
	public static <I> ImmutableTypedMap<I> of(I k1, TypedSupplier<?> v1, I k2, TypedSupplier<?> v2) {
		return new RegularImmutableTypedMap<I>(ImmutableMap.of(k1, v1, k2, v2));
	}

	/**
	 * Returns an immutable map containing the given entries, in order.
	 * 
	 * @throws IllegalArgumentException if duplicate keys are provided
	 */
	public static <I> ImmutableTypedMap<I> of(I k1, TypedSupplier<?> v1, I k2, TypedSupplier<?> v2, I k3,
			TypedSupplier<?> v3) {
		return new RegularImmutableTypedMap<I>(ImmutableMap.of(k1, v1, k2, v2, k3, v3));
	}

	/**
	 * Returns an immutable map containing the given entries, in order.
	 * 
	 * @throws IllegalArgumentException if duplicate keys are provided
	 */
	public static <I> ImmutableTypedMap<I> of(I k1, TypedSupplier<?> v1, I k2, TypedSupplier<?> v2, I k3,
			TypedSupplier<?> v3, I k4, TypedSupplier<?> v4) {
		return new RegularImmutableTypedMap<I>(ImmutableMap.of(k1, v1, k2, v2, k3, v3, k4, v4));
	}

	/**
	 * Returns an immutable map containing the given entries, in order.
	 * 
	 * @throws IllegalArgumentException if duplicate keys are provided
	 */
	public static <I> ImmutableTypedMap<I> of(I k1, TypedSupplier<?> v1, I k2, TypedSupplier<?> v2, I k3,
			TypedSupplier<?> v3, I k4, TypedSupplier<?> v4, I k5, TypedSupplier<?> v5) {
		return new RegularImmutableTypedMap<I>(ImmutableMap.of(k1, v1, k2, v2, k3, v3, k4, v4, k5, v5));
	}

	// looking for of() with > 5 entries? Use the builder instead.

	/**
	 * Returns a new builder. The generated builder is equivalent to the builder created by the {@link Builder}
	 * constructor.
	 */
	@Nonnull
	public static <I> Builder<I> builder() {
		return new Builder<I>();
	}

	public static class Builder<K> {
		final ImmutableMap.Builder<K, TypedSupplier<?>> builder = ImmutableMap.builder();

		/**
		 * Creates a new builder. The returned builder is equivalent to the builder generated by
		 * {@link ImmutableTypedMap#builder}.
		 */
		public Builder() {
		}

		/**
		 * Associates the untyped {@code key} with the typed {@code value} in the built map. Duplicate keys are not
		 * allowed, and will cause {@link #build} to fail.
		 */
		public Builder<K> put(K key, TypedSupplier<?> value) {
			builder.put(key, value);
			return this;
		}

		/**
		 * Associates the typed {@code key} with the untyped {@code value} in the built map. Duplicate keys are not
		 * allowed, and will cause {@link #build} to fail.
		 */
		public <TT> Builder<K> put(TypedKey<TT, K> key, TT value) {
			builder.put(key.getId(), ImmutableTypedSupplier.create(key.getType(), value));
			return this;
		}

		/**
		 * Adds the given {@code entry} to the map, making it immutable if necessary. Duplicate keys are not allowed,
		 * and will cause {@link #build} to fail.
		 * 
		 * @since 11.0
		 */
		public Builder<K> put(Entry<K, ? extends TypedSupplier<?>> entry) {
			builder.put(entry);
			return this;
		}

		/**
		 * Associates all of the given map's keys and values in the built map. Duplicate keys are not allowed, and will
		 * cause {@link #build} to fail.
		 * 
		 * Note: there is no {@code putAll} for a {@code Map<TypedKey<?>, Object>} because the required generic type
		 * checking cannot be done at runtime.
		 * 
		 * @throws NullPointerException if any key or value in {@code map} is null
		 */
		public Builder<K> putAll(Map<K, ? extends TypedSupplier<?>> map) {
			builder.putAll(map);
			return this;
		}

		/**
		 * Returns a newly-created immutable map.
		 * 
		 * @throws IllegalArgumentException if duplicate keys were added
		 */
		public ImmutableTypedMap<K> build() {
			return fromEntryList(builder.build());
		}

		private static <I> ImmutableTypedMap<I> fromEntryList(ImmutableMap<I, TypedSupplier<?>> m) {
			int size = m.size();
			switch (size) {
			case 0:
				return of();
			default:
				return new RegularImmutableTypedMap<I>(m);
			}
		}

	}

	/**
	 * Delegate accessor (read-only).
	 * 
	 * @return the immutable map that this typed map delegates to
	 */
	abstract ImmutableMap<? extends ID, ? extends TypedSupplier<?>> delegate();

	public int size() {
		return delegate().size();
	}

	public boolean isEmpty() {
		return delegate().isEmpty();
	}

	/**
	 * @returns true for all keys().contains(typedKey) where the provided key type is assignable from the contained key type.
	 */
	public <T> boolean contains(@Nonnull TypedKey<T, ? extends ID> typedKey) {
		TypedSupplier<?> valueSupplier = delegate().get(typedKey.getId());
		if (valueSupplier == null) {
			return false;
		}
		return typedKey.getType().isAssignableFrom(valueSupplier.getType());
	}
	
	/**
	 * @returns true if there exists a key in the map with the provided ID.
	 */
	public <T> boolean contains(@Nonnull ID id) {
		TypedSupplier<?> valueSupplier = delegate().get(id);
		return valueSupplier != null;
	}

	@Nonnull
	public <T> T get(@Nonnull TypedKey<T, ? extends ID> typedKey) throws EntryNotFoundException, ClassCastException {
		TypedSupplier<?> valueSupplier = delegate().get(typedKey.getId());
		if (valueSupplier == null) {
			throw new EntryNotFoundException("Value does not exist for the key: " + typedKey);
		}
		TypedSupplier<T> typedSupplier = checkValueType(typedKey.getType(), valueSupplier);
		return typedSupplier.get();
	}
	
	@Nonnull
	public Object get(@Nonnull ID id) throws EntryNotFoundException {
		TypedSupplier<?> valueSupplier = delegate().get(id);
		if (valueSupplier == null) {
			throw new EntryNotFoundException("Value does not exist for the key ID: " + id);
		}
		return valueSupplier.get();
	}
	
	private transient ImmutableSet<? extends Entry<? extends TypedKey<?, ? extends ID>, ?>> entrySet;

	@Nonnull
	public ImmutableSet<? extends Entry<? extends TypedKey<?, ? extends ID>, ?>> entries() {
		ImmutableSet<? extends Entry<? extends TypedKey<?, ? extends ID>, ?>> result = entrySet;
		return (result == null) ? entrySet = createEntrySet() : result;
	}
	
	@Nonnull
	ImmutableSet<? extends Entry<? extends TypedKey<?, ? extends ID>, ?>> createEntrySet() {
		//TODO: use a lazy iterator?
		//based on the cachable entrySupplierSet
		return ImmutableSet.copyOf(Collections2.transform(entrySuppliers(), new EntryToKeyedEntryTransform()));
	}
	
	class EntryToKeyedEntryTransform implements Function<Entry<? extends ID, ? extends TypedSupplier<?>>, Entry<? extends TypedKey<?, ? extends ID>, ?>> {
		public Entry<? extends TypedKey<?, ? extends ID>, ?> apply(Entry<? extends ID, ? extends TypedSupplier<?>> input) {
			TypedSupplier<?> valueSupplier = input.getValue();
			return Maps.immutableEntry(ImmutableTypedKey.create(valueSupplier.getType(), input.getKey()), valueSupplier.get());
		}
	};
	
	private transient ImmutableSet<? extends Entry<? extends ID, ? extends TypedSupplier<?>>> entrySupplierSet;

	/**
	 * Returns an immutable set of the mappings in this map. The entries are in the same order as the parameters used to
	 * build this map.
	 */
	@Nonnull
	public ImmutableSet<? extends Entry<? extends ID, ? extends TypedSupplier<?>>> entrySuppliers() {
		ImmutableSet<? extends Entry<? extends ID, ? extends TypedSupplier<?>>> result = entrySupplierSet;
		return (result == null) ? entrySupplierSet = createEntrySupplierSet() : result;
	}

	@Nonnull
	ImmutableSet<? extends Entry<? extends ID, ? extends TypedSupplier<?>>> createEntrySupplierSet() {
		return delegate().entrySet();
	}

	private transient ImmutableSet<? extends TypedKey<?, ? extends ID>> typedKeySet;

	/**
	 * Returns an immutable set of the typed keys in this map. These typed keys are in the same order as the parameters
	 * used to build this map.
	 */
	@Nonnull
	public ImmutableSet<? extends TypedKey<?, ? extends ID>> keys() {
		ImmutableSet<? extends TypedKey<?, ? extends ID>> result = typedKeySet;
		return (result == null) ? typedKeySet = createKeySet() : result;
	}

	@Nonnull
	ImmutableSet<? extends TypedKey<?, ? extends ID>> createKeySet() {
		//TODO: use a lazy iterator?
		//based on the cachable entrySupplierSet
		return ImmutableSet.copyOf(Collections2.transform(entrySuppliers(), new EntryToTypedKeyTransform()));
	}

	class EntryToTypedKeyTransform implements Function<Entry<? extends ID, ? extends TypedSupplier<?>>, TypedKey<?, ID>> {
		public TypedKey<?, ID> apply(Entry<? extends ID, ? extends TypedSupplier<?>> input) {
			return ImmutableTypedKey.create(input.getValue().getType(), (ID) input.getKey());
		}
	};

	@Nonnull
	static <TT> TypedSupplier<TT> checkValueType(@Nonnull TypeToken<TT> type, @Nonnull TypedSupplier<?> valueSupplier)
			throws ClassCastException {
		if (!type.isAssignableFrom(valueSupplier.getType())) {
			throw new ClassCastException("Key type is not assignable from the existing value type.");
		}
		@SuppressWarnings("unchecked")
		TypedSupplier<TT> typedSupplier = (TypedSupplier<TT>) valueSupplier;
		return typedSupplier;
	}

	@Override
	public boolean equals(@Nullable Object object) {
		return TypedMaps.equalsImpl(this, object);
	}

	@Override
	public int hashCode() {
		// not caching hash code since it could change if map values are mutable in a way that modifies their hash codes
		return entries().hashCode();
	}

	@Override
	public String toString() {
		return TypedMaps.toStringImpl(this);
	}

}
