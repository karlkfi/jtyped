package karlkfi.jtyped.map;

import java.util.Collections;
import java.util.Map;
import java.util.Map.Entry;

import javax.annotation.Nonnull;
import javax.annotation.Nullable;

import karlkfi.jtyped.IdentityTypedSupplier;
import karlkfi.jtyped.TypedSupplier;

import com.google.common.base.Function;
import com.google.common.base.Supplier;
import com.google.common.collect.Collections2;
import com.google.common.collect.ImmutableCollection;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;
import com.google.common.reflect.TypeToken;

/**
 * Immutable TypedMap that is backed by an {@link ImmutableMap}.
 */
public abstract class ImmutableTypedMap<K> implements TypedMap<K> {

	/**
	 * Returns the empty typed map.
	 */
	// Casting to any type is safe because the set will never hold any elements.
	@SuppressWarnings("unchecked")
	public static <KK> ImmutableTypedMap<KK> of() {
		return (ImmutableTypedMap<KK>) EmptyImmutableTypedMap.INSTANCE;
	}

	/**
	 * Returns an immutable typed map containing a single entry. This map behaves and performs comparably to
	 * {@link Collections#singletonMap} but will not accept a null key or value. It is preferable mainly for consistency
	 * and maintainability of your code.
	 */
	public static <KK> ImmutableTypedMap<KK> of(KK k1, TypedSupplier<?> v1) {
		return new RegularImmutableTypedMap<KK>(ImmutableMap.of(k1, v1));
	}

	/**
	 * Returns an immutable map containing the given entries, in order.
	 * 
	 * @throws IllegalArgumentException if duplicate keys are provided
	 */
	public static <KK> ImmutableTypedMap<KK> of(KK k1, TypedSupplier<?> v1, KK k2, TypedSupplier<?> v2) {
		return new RegularImmutableTypedMap<KK>(ImmutableMap.of(k1, v1, k2, v2));
	}

	/**
	 * Returns an immutable map containing the given entries, in order.
	 * 
	 * @throws IllegalArgumentException if duplicate keys are provided
	 */
	public static <KK> ImmutableTypedMap<KK> of(KK k1, TypedSupplier<?> v1, KK k2, TypedSupplier<?> v2, KK k3,
			TypedSupplier<?> v3) {
		return new RegularImmutableTypedMap<KK>(ImmutableMap.of(k1, v1, k2, v2, k3, v3));
	}

	/**
	 * Returns an immutable map containing the given entries, in order.
	 * 
	 * @throws IllegalArgumentException if duplicate keys are provided
	 */
	public static <KK> ImmutableTypedMap<KK> of(KK k1, TypedSupplier<?> v1, KK k2, TypedSupplier<?> v2, KK k3,
			TypedSupplier<?> v3, KK k4, TypedSupplier<?> v4) {
		return new RegularImmutableTypedMap<KK>(ImmutableMap.of(k1, v1, k2, v2, k3, v3, k4, v4));
	}

	/**
	 * Returns an immutable map containing the given entries, in order.
	 * 
	 * @throws IllegalArgumentException if duplicate keys are provided
	 */
	public static <KK> ImmutableTypedMap<KK> of(KK k1, TypedSupplier<?> v1, KK k2, TypedSupplier<?> v2, KK k3,
			TypedSupplier<?> v3, KK k4, TypedSupplier<?> v4, KK k5, TypedSupplier<?> v5) {
		return new RegularImmutableTypedMap<KK>(ImmutableMap.of(k1, v1, k2, v2, k3, v3, k4, v4, k5, v5));
	}

	// looking for of() with > 5 entries? Use the builder instead.

	/**
	 * Returns a new builder. The generated builder is equivalent to the builder created by the {@link Builder}
	 * constructor.
	 */
	@Nonnull
	public static <KK> Builder<KK> builder() {
		return new Builder<KK>();
	}

	public static class Builder<K> {
		final ImmutableMap.Builder<K, TypedSupplier<?>> builder = ImmutableMap.builder();

		/**
		 * Creates a new builder. The returned builder is equivalent to the builder generated by
		 * {@link ImmutableTypedMap#builder}.
		 */
		public Builder() {
		}

		/**
		 * Associates the untyped {@code key} with the typed {@code value} in the built map. Duplicate keys are not
		 * allowed, and will cause {@link #build} to fail.
		 */
		public Builder<K> put(K key, TypedSupplier<?> value) {
			builder.put(key, value);
			return this;
		}

		/**
		 * Associates the typed {@code key} with the untyped {@code value} in the built map. Duplicate keys are not
		 * allowed, and will cause {@link #build} to fail.
		 */
		public <TT> Builder<K> put(TypedKey<TT, K> key, TT value) {
			builder.put(key.getKey(), IdentityTypedSupplier.create(key.getType(), value));
			return this;
		}

		/**
		 * Adds the given {@code entry} to the map, making it immutable if necessary. Duplicate keys are not allowed,
		 * and will cause {@link #build} to fail.
		 * 
		 * @since 11.0
		 */
		public Builder<K> put(Entry<K, ? extends TypedSupplier<?>> entry) {
			builder.put(entry);
			return this;
		}

		/**
		 * Associates all of the given map's keys and values in the built map. Duplicate keys are not allowed, and will
		 * cause {@link #build} to fail.
		 * 
		 * Note: there is no {@code putAll} for a {@code Map<TypedKey<?>, Object>} because the required generic type
		 * checking cannot be done at runtime.
		 * 
		 * @throws NullPointerException if any key or value in {@code map} is null
		 */
		public Builder<K> putAll(Map<K, ? extends TypedSupplier<?>> map) {
			builder.putAll(map);
			return this;
		}

		/**
		 * Returns a newly-created immutable map.
		 * 
		 * @throws IllegalArgumentException if duplicate keys were added
		 */
		public ImmutableTypedMap<K> build() {
			return fromEntryList(builder.build());
		}

		private static <KK> ImmutableTypedMap<KK> fromEntryList(ImmutableMap<KK, TypedSupplier<?>> m) {
			int size = m.size();
			switch (size) {
			case 0:
				return of();
			default:
				return new RegularImmutableTypedMap<KK>(m);
			}
		}

	}

	/**
	 * Delegate accessor (read-only).
	 * 
	 * @return the immutable map that this typed map delegates to
	 */
	abstract ImmutableMap<? extends K, ? extends TypedSupplier<?>> delegate();

	public int size() {
		return delegate().size();
	}

	public boolean isEmpty() {
		return delegate().isEmpty();
	}

	public <TT> boolean containsKey(TT key) {
		return delegate().containsKey(key);
	}

	public <TT> boolean containsTypedKey(TypedKey<TT, ? extends K> typedKey) {
		// TODO Auto-generated method stub
		return false;
	}

	public <TT> boolean containsValue(TT value) {
		// TODO Auto-generated method stub
		return false;
	}

	public <TT> boolean containsTypedValue(TypedSupplier<TT> valueSupplier) {
		return delegate().containsValue(valueSupplier);
	}

	public <TT> TT get(TypedKey<TT, ? extends K> typedKey) throws EntryNotFoundException, ClassCastException {
		TypedSupplier<?> valueSupplier = delegate().get(typedKey.getKey());
		if (valueSupplier == null) {
			throw new EntryNotFoundException("Value does not exist for the key: " + typedKey);
		}
		TypedSupplier<TT> typedSupplier = checkValueType(typedKey.getType(), valueSupplier);
		return typedSupplier.get();
	}

	public <TT> TypedSupplier<TT> getSupplier(TypedKey<TT, ? extends K> typedKey) throws EntryNotFoundException,
			ClassCastException {
		TypedSupplier<?> valueSupplier = delegate().get(typedKey.getKey());
		if (valueSupplier == null) {
			throw new EntryNotFoundException("Value does not exist for the key: " + typedKey);
		}
		TypedSupplier<TT> typedSupplier = checkValueType(typedKey.getType(), valueSupplier);
		return typedSupplier;
	}

	private transient ImmutableSet<? extends Entry<? extends K, ? extends TypedSupplier<?>>> entrySet;

	/**
	 * Returns an immutable set of the mappings in this map. The entries are in the same order as the parameters used to
	 * build this map.
	 */
	public ImmutableSet<? extends Entry<? extends K, ? extends TypedSupplier<?>>> entrySet() {
		ImmutableSet<? extends Entry<? extends K, ? extends TypedSupplier<?>>> result = entrySet;
		return (result == null) ? entrySet = createEntrySet() : result;
	}

	ImmutableSet<? extends Entry<? extends K, ? extends TypedSupplier<?>>> createEntrySet() {
		return delegate().entrySet();
	}

	private transient ImmutableSet<? extends K> keySet;

	/**
	 * Returns an immutable set of the keys in this map. These keys are in the same order as the parameters used to
	 * build this map.
	 */
	public ImmutableSet<? extends K> keySet() {
		ImmutableSet<? extends K> result = keySet;
		return (result == null) ? keySet = createKeySet() : result;
	}

	ImmutableSet<? extends K> createKeySet() {
		return delegate().keySet();
	}

	private transient ImmutableSet<? extends TypedKey<?, ? extends K>> typedKeySet;

	/**
	 * Returns an immutable set of the typed keys in this map. These typed keys are in the same order as the parameters
	 * used to build this map.
	 */
	public ImmutableSet<? extends TypedKey<?, ? extends K>> typedKeySet() {
		ImmutableSet<? extends TypedKey<?, ? extends K>> result = typedKeySet;
		return (result == null) ? typedKeySet = createTypedKeySet() : result;
	}

	ImmutableSet<? extends TypedKey<?, ? extends K>> createTypedKeySet() {
		//TODO: use a lazy iterator?
		//based on the cachable entrySet
		return ImmutableSet.copyOf(Collections2.transform(entrySet(), new EntryToTypedKeyTransform()));
	}

	class EntryToTypedKeyTransform implements Function<Entry<? extends K, ? extends TypedSupplier<?>>, TypedKey<?, K>> {
		public TypedKey<?, K> apply(Entry<? extends K, ? extends TypedSupplier<?>> input) {
			return ImmutableTypedKey.create(input.getValue().getType(), (K) input.getKey());
		}
	};

	private transient ImmutableCollection<?> values;

	/**
	 * Returns an immutable collection of the values in this map. The values are in the same order as the parameters
	 * used to build this map.
	 */
	public ImmutableCollection<?> values() {
		ImmutableCollection<?> result = values;
		return (result == null) ? values = createValues() : result;
	}

	ImmutableCollection<?> createValues() {
		//TODO: use a lazy iterator?
		//based on the cachable valueSuppliers
		return ImmutableList.copyOf(Collections2.transform(valueSuppliers(), new SupplierFunction()));
	}

	class SupplierFunction implements Function<Supplier<?>, Object> {
		public Object apply(Supplier<?> input) {
			return input.get();
		}
	}

	private transient ImmutableCollection<? extends TypedSupplier<?>> valueSuppliers;

	/**
	 * Returns an immutable collection of the value suppliers in this map. The value suppliers are in the same order as
	 * the parameters used to build this map.
	 */
	public ImmutableCollection<? extends TypedSupplier<?>> valueSuppliers() {
		ImmutableCollection<? extends TypedSupplier<?>> result = valueSuppliers;
		return (result == null) ? valueSuppliers = createValueSuppliers() : result;
	}

	ImmutableCollection<? extends TypedSupplier<?>> createValueSuppliers() {
		return delegate().values();
	}

	static <TT> TypedSupplier<TT> checkValueType(TypeToken<TT> type, TypedSupplier<?> valueSupplier)
			throws ClassCastException {
		if (!type.isAssignableFrom(valueSupplier.getType())) {
			throw new ClassCastException("Key type is not assignable from the existing value type.");
		}
		@SuppressWarnings("unchecked")
		TypedSupplier<TT> typedSupplier = (TypedSupplier<TT>) valueSupplier;
		return typedSupplier;
	}

	@Override
	public boolean equals(@Nullable Object object) {
		return TypedMaps.equalsImpl(this, object);
	}

	@Override
	public int hashCode() {
		// not caching hash code since it could change if map values are mutable in a way that modifies their hash codes
		return entrySet().hashCode();
	}

	@Override
	public String toString() {
		return TypedMaps.toStringImpl(this);
	}

}
